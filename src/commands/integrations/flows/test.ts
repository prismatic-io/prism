import { Flags, ux } from "@oclif/core";
import { decode } from "@msgpack/msgpack";
import open from "open";
import { getAccessToken, prismaticUrl } from "../../../auth.js";
import { PrismaticBaseCommand } from "../../../baseCommand.js";
import { fetch } from "../../../utils/http.js";
import {
  isCniExecutionComplete,
  FetchLogsResult,
  getExecutionLogs,
  getExecutionStepResults,
  LogNode,
  StepResultNode,
  selectFlowPrompt,
  getIntegrationFlows,
  type IntegrationFlow,
} from "../../../utils/integration/flows.js";
import { getTriggerType } from "./listen.js";
import { exists, fs } from "../../../fs.js";
import { getPrismMetadata } from "../../../utils/integration/metadata.js";
import { handleError } from "../../../utils/errors.js";
import {
  getIntegrationSystemId,
  isIntegrationConfigured,
} from "../../../utils/integration/query.js";
import { getAdaptivePollIntervalMs } from "../../../utils/polling.js";

type FormattedStepResult = {
  stepName: string;
  endedAt: string;
  result: Record<string, unknown>;
};

/** Payload format generated by the listen command for replay */
type ReplayablePayload = {
  flowId?: string;
  payload: unknown;
  contentType: string;
  headers: string | Record<string, string>;
  triggerType?: "WEBHOOK" | "POLLING";
};

const MISSING_ID_ERROR = "You must provide either a flow-id or integration-id parameter.";
const TIMEOUT_SECONDS = 1200; // 20 minutes

export const CONFIGURE_INSTANCE_PARAMS = {
  embed: "true",
  theme: "LIGHT",
  reconfigure: "true",
  screenConfiguration: JSON.stringify({
    configurationWizard: {
      mode: "streamlined",
    },
  }),
};

export default class TestFlowCommand extends PrismaticBaseCommand {
  private startTime = 0;

  static description = "Run a test execution of a flow";

  static examples = [
    {
      description:
        "Test an integration flow with a payload file and tail the logs and step results:",
      command:
        "<%= config.bin %> <%= command.id %> -p=some_payload_file.xml -c=application/xml --tail-logs --tail-results",
    },
  ];

  static flags = {
    "flow-id": Flags.string({
      char: "f",
      description: "ID of the flow to test. Base64 encoded.",
      exclusive: ["flow-url"],
    }),
    "flow-url": Flags.string({
      char: "u",
      description: "URL of the flow to test. Prefer to use flow-id instead, if possible.",
      exclusive: ["flow-id"],
    }),
    "integration-id": Flags.string({
      // We do not require this flag because we can often detect it in the project files.
      char: "i",
      description: "ID of the integration containing the flow to test. Base64 encoded.",
    }),
    payload: Flags.string({
      char: "p",
      description: "Optional file containing a payload to run the flow with.",
    }),
    "payload-content-type": Flags.string({
      char: "c",
      description: "Optional Content-Type for the test payload.",
      default: "application/json",
    }),
    sync: Flags.boolean({
      description: "Forces the flow to run synchronously.",
    }),
    "tail-results": Flags.boolean({
      description: "Tail step results from the test execution until user interrupt or timeout.",
    }),
    "tail-logs": Flags.boolean({
      description: "Tail logs from the test execution until user interrupt or timeout.",
    }),
    "cni-auto-end": Flags.boolean({
      description:
        "Automatically stop polling activity once an CNI flow execution completes. Some logs & results may not be returned this way. DOES NOT WORK FOR LOW-CODE FLOWS.",
    }),
    timeout: Flags.integer({
      description:
        "Optionally set a timeout (in seconds) to stop tail activity. Compatible with both low-code and CNI flows.",
    }),
    "result-file": Flags.string({
      char: "r",
      description:
        "Optional file to append tailed execution result data to. Results are saved into JSON Lines.",
    }),
    jsonl: Flags.boolean({
      description: "Optionally format the step and tail results output into JSON Lines.",
    }),
    debug: Flags.boolean({
      description: "Enables debug mode on the test execution.",
    }),
    apiKey: Flags.string({
      description: "Optional API key for flows with secured endpoints.",
    }),
  };

  async run() {
    const {
      flags: {
        sync,
        "flow-id": flowIdFlag,
        "flow-url": flowUrlFlag,
        "integration-id": integrationIdFlag,
        payload: payloadFilePath,
        "payload-content-type": contentType,
        "tail-logs": tailLogs,
        "tail-results": tailStepResults,
        "cni-auto-end": autoEndPoll,
        "result-file": resultFilePath,
        timeout,
        debug,
        quiet,
        apiKey,
      },
    } = await this.parse(TestFlowCommand);

    let triggerPayload = "";
    let payloadHeaders: Record<string, string> = {};
    let effectiveContentType = contentType;
    let replayablePayload: ReplayablePayload | null = null;

    if (payloadFilePath) {
      if (!(await exists(payloadFilePath))) {
        handleError({
          message: `No file found at ${payloadFilePath}. Please check the --trigger-payload-file (-p) parameter.`,
          throwError: true,
        });
      }

      const fileContent = await fs.readFile(payloadFilePath, { encoding: "utf-8" });
      replayablePayload = parseReplayablePayload(fileContent);

      if (replayablePayload) {
        // If the given payload file is from listening mode replay, we will parse it for
        // the body, content type, and headers, and merge that in with the given flags accordingly.
        triggerPayload =
          typeof replayablePayload.payload === "string"
            ? replayablePayload.payload
            : JSON.stringify(replayablePayload.payload);

        const hasExplicitContentType =
          this.argv.includes("-c") ||
          this.argv.some(
            (arg) => arg.startsWith("-c=") || arg.startsWith("--payload-content-type"),
          );
        if (!hasExplicitContentType && replayablePayload.contentType) {
          effectiveContentType = replayablePayload.contentType;
        }

        if (typeof replayablePayload.headers === "string") {
          try {
            payloadHeaders = JSON.parse(replayablePayload.headers);
          } catch {
            throw new Error(
              `There was an error parsing the headers listed in the payload file: ${payloadFilePath}`,
            );
          }
        } else if (
          typeof replayablePayload.headers === "object" &&
          replayablePayload.headers !== null
        ) {
          payloadHeaders = replayablePayload.headers;
        }
      } else {
        // Not a replayable payload, use file content as-is (legacy behavior)
        triggerPayload = fileContent;

        // Validate JSON if that's what we're expecting
        if (contentType === "application/json") {
          try {
            JSON.parse(fileContent);
          } catch {
            handleError({
              message:
                "The provided trigger payload file contains malformed JSON. Please check the payload file (-p) and Content-Type (-c).",
              throwError: true,
            });
          }
        }
      }
    }

    let integrationId = integrationIdFlag;
    let invokeUrl = "";
    let selectedFlowId: string | undefined = flowIdFlag;
    let selectedFlow: IntegrationFlow | undefined;

    if (flowUrlFlag) {
      // flow-url provided - use it directly.
      invokeUrl = flowUrlFlag;
    } else {
      // Need integration ID to look up flow data
      if (!integrationId) {
        try {
          const metadata = await getPrismMetadata();
          integrationId = metadata.integrationId;

          if (!integrationId) {
            throw new Error();
          }
        } catch (err) {
          handleError({
            message: MISSING_ID_ERROR,
            throwError: true,
          });
          throw err;
        }
      }

      // Once we have an integration ID, we should validate that it's fully configured for testing.
      // Unfortunately can't do this in the direct invocation path b/c there's no reasonable way to
      // reverse-lookup integration ID from a webhook URL.
      const integrationIsValid = await validateIntegrationConfiguration(integrationId, quiet);
      if (!integrationIsValid) {
        return;
      }

      if (!selectedFlowId) {
        // Without a provided flowId, we need to prompt the user to select one.
        selectedFlow = await selectFlowPrompt(integrationId, {
          message: "Select the flow to test:",
        });
        selectedFlowId = selectedFlow.id;

        if (!selectedFlowId) {
          handleError({ message: MISSING_ID_ERROR, throwError: true });
        }
      } else {
        // flow-id was provided, look up the flow from integration to get trigger info
        const flows = await getIntegrationFlows(integrationId);
        selectedFlow = flows.find((flow) => flow.id === selectedFlowId);

        if (!selectedFlow) {
          handleError({
            message: `Could not find flow with ID ${selectedFlowId} in integration ${integrationId}. Please verify that the flow ID is correct.`,
            throwError: true,
          });
        }
      }

      // Use the test URL from the selected flow
      if (selectedFlow) {
        invokeUrl = selectedFlow.testUrl;
      }
    }

    const isPollingFromPayload = replayablePayload?.triggerType === "POLLING";
    const isPolling =
      isPollingFromPayload ||
      (selectedFlow ? getTriggerType(selectedFlow.trigger) === "POLLING" : false);

    if (flowUrlFlag && triggerPayload && !isPollingFromPayload) {
      // Warn when using flow-url with a non-replayable payload - we can't detect polling triggers w/o ID's
      this.warn(
        "This command cannot detect polling triggers when using --flow-url. If this is a polling flow, use a replayable payload from `flows:listen` or use --flow-id instead.",
      );
    }

    ux.action.start("Starting execution...");

    // For polling flows with a payload, pass the payload via the simulated trigger result header
    let simulatedTriggerResult: string | undefined;
    if (isPolling && triggerPayload) {
      try {
        simulatedTriggerResult = JSON.stringify({
          payload: { body: { data: JSON.parse(triggerPayload) } },
        });
      } catch {
        simulatedTriggerResult = JSON.stringify({
          payload: { body: { data: triggerPayload } },
        });
      }
    }

    const response = await fetch(invokeUrl, {
      method: "POST",
      body: isPolling ? undefined : triggerPayload,
      headers: {
        ...payloadHeaders,
        ...(debug ? { "prismatic-debug": "true" } : {}),
        ...(apiKey ? { "Api-Key": apiKey } : {}),
        ...(sync ? { "prismatic-synchronous": "true" } : {}),
        ...(simulatedTriggerResult
          ? { "prismatic-simulated-trigger-result": simulatedTriggerResult }
          : {}),
        ...(triggerPayload ? { "Content-Type": effectiveContentType } : {}),
      },
    });
    const responseData = (await response.json()) as any;
    const executionId = response.headers.get("prismatic-executionid") || "";

    ux.action.stop();

    this.startTime = Date.now();

    const flagString = buildFlagString({
      payloadFilePath,
      contentType,
      tailLogs,
      tailStepResults,
      sync,
      autoEndPoll,
      resultFilePath,
    });

    // Prefer flow-id for re-run hint, fall back to flow-url if that's what was provided
    const flowArg = selectedFlowId ? `-f=${selectedFlowId}` : `-u=${invokeUrl}`;

    this.quietLog(
      `
To re-run this flow directly:
prism integrations:flows:test ${flowArg} ${flagString}
`,
      quiet,
    );

    if (!responseData?.executionId) {
      this.log(`Execution ID: ${executionId}\n`);
    }

    this.log(`${JSON.stringify(responseData, null, 2)}\n`);

    if (!(tailLogs || tailStepResults)) return;

    this.quietLog(
      "While the timestamps are accurate, logs & step results may not arrive in chronological order.",
      quiet,
      "warn",
    );
    this.quietLog(
      `\nPress CMD+C/CTRL+C to stop polling. ${
        autoEndPoll
          ? ""
          : `This process will timeout after ${timeout ? `${timeout / 60} minutes` : "20 minutes"}.`
      }\n`,
      quiet,
    );

    const tailPromises = [];
    this.startTime = Date.now();

    if (tailLogs) tailPromises.push(this.tailLogs(executionId));
    if (tailStepResults) tailPromises.push(this.tailStepResults(executionId));

    let timeoutTimer: NodeJS.Timeout | undefined = undefined;
    const timeoutPromise = new Promise<void>((resolve) => {
      timeoutTimer = setTimeout(
        () => {
          this.quietLog("Timeout reached. Stopping polling.", quiet);
          process.exit(0);
        },
        (timeout ?? TIMEOUT_SECONDS) * 1000,
      );
    });
    await Promise.race([Promise.all(tailPromises), timeoutPromise]);

    // Clear the timeout to allow process to exit cleanly
    if (timeoutTimer) {
      clearTimeout(timeoutTimer);
    }
  }

  private async tailLogs(executionId: string) {
    const {
      flags: { "cni-auto-end": autoEndPoll, "result-file": resultFilePath, timeout, jsonl },
    } = await this.parse(TestFlowCommand);

    let nextCursor: string | undefined = undefined;

    while (true) {
      await ux.wait(getAdaptivePollIntervalMs(this.startTime));

      const result = await this.fetchLogs(executionId, nextCursor);
      if (result === undefined) continue;

      const { logs, cursor } = result;
      nextCursor = cursor;

      if (jsonl) {
        logs.forEach((result) => {
          this.log(JSON.stringify(result));
        });
      } else {
        ux.table(
          logs,
          {
            timestamp: {},
            severity: {
              get: (row) => `LOG_${row.severity}`,
              minWidth: 15,
            },
            message: {},
          },
          {
            "no-header": true,
          },
        );
      }

      if (resultFilePath) {
        for (const log of logs) {
          await fs.appendFile(resultFilePath, JSON.stringify(log));
        }
      }

      if (await this.shouldEnd(executionId, autoEndPoll, timeout)) {
        return;
      }
    }
  }

  private async tailStepResults(executionId: string) {
    const {
      flags: { "cni-auto-end": autoEndPoll, "result-file": resultFilePath, timeout, jsonl },
    } = await this.parse(TestFlowCommand);

    let nextCursor: string | undefined = undefined;

    while (true) {
      await ux.wait(getAdaptivePollIntervalMs(this.startTime));

      const result = await this.fetchStepResults(executionId, nextCursor);
      if (result === undefined) {
        continue;
      }

      const { stepResults, cursor } = result;
      nextCursor = cursor;

      if (jsonl) {
        stepResults.forEach((result) => {
          this.log(JSON.stringify(result));
        });
      } else {
        ux.table(
          stepResults,
          {
            endedAt: {},
            stepName: {
              get: (row) => `STEP_${row.stepName}`,
              minWidth: 15,
            },
            result: {},
          },
          {
            "no-header": true,
          },
        );
      }

      if (resultFilePath) {
        for (const result of stepResults) {
          await fs.appendFile(resultFilePath, JSON.stringify(stepResults));
        }
      }

      if (await this.shouldEnd(executionId, autoEndPoll, timeout)) {
        return;
      }
    }
  }

  private async fetchLogs(
    executionId: string,
    nextCursor?: string,
  ): Promise<FetchLogsResult | undefined> {
    const results = await getExecutionLogs(executionId, nextCursor);

    const { edges } = results.logs;
    if (!edges || edges.length === 0) {
      return undefined;
    }

    const logs = edges.flatMap((edge) => (edge?.node ? [edge.node] : []));

    const lastEdge = edges[edges.length - 1];
    const cursor = lastEdge?.cursor;
    return { logs, cursor };
  }

  private async fetchStepResults(executionId: string, nextCursor?: string) {
    const results = await getExecutionStepResults(executionId, nextCursor);

    const { edges } = results.executionResult?.stepResults ?? { edges: [] };

    if (!edges || edges.length === 0) {
      return undefined;
    }

    const stepResults: Array<FormattedStepResult> = [];

    for (const edge of edges) {
      if (!edge?.node) continue;
      const { endedAt, resultsUrl, stepName } = edge.node;

      try {
        const response = await fetch(resultsUrl);
        const arrayBuffer = await response.arrayBuffer();
        const resultsBuffer = Buffer.from(arrayBuffer);
        const result = decode(resultsBuffer) as Record<string, unknown>;

        stepResults.push({
          stepName: stepName ?? "unknown",
          endedAt: endedAt ?? "",
          result,
        });
      } catch (err) {
        // Allow the process to keep running, just skip rendering the step result.
        handleError({
          message: `There was an error fetching step results for step: ${stepName}`,
          err,
          throwError: false,
        });
      }
    }

    const lastEdge = edges[edges.length - 1];
    const cursor = lastEdge?.cursor;
    return { stepResults, cursor };
  }

  private async shouldEnd(executionId: string, autoEndPoll: boolean, timeout = TIMEOUT_SECONDS) {
    return (
      Date.now() - this.startTime > timeout * 1000 ||
      (autoEndPoll && (await isCniExecutionComplete(executionId)))
    );
  }
}

function parseReplayablePayload(content: string): ReplayablePayload | null {
  try {
    const parsed = JSON.parse(content);
    if (
      typeof parsed === "object" &&
      parsed !== null &&
      "payload" in parsed &&
      "contentType" in parsed &&
      "headers" in parsed
    ) {
      return parsed as ReplayablePayload;
    }
    return null;
  } catch {
    return null;
  }
}

async function validateIntegrationConfiguration(integrationId: string, quiet: boolean) {
  const isConfigured = await isIntegrationConfigured(integrationId);
  const systemInstanceId = await getIntegrationSystemId(integrationId);

  if (!isConfigured) {
    console.warn("The integration needs to be configured before it can be tested.");
  }

  const accessToken = await getAccessToken();
  const params = new URLSearchParams({
    ...CONFIGURE_INSTANCE_PARAMS,
    ...(accessToken && { jwt: accessToken }),
  });
  const configUrl = `${prismaticUrl}/configure-instance/${systemInstanceId}/?${params.toString()}`;

  if (!isConfigured) {
    if (quiet) {
      console.warn(`Configure the test instance by visiting the following URL:\n${configUrl}`);
    } else {
      const shouldOpen = await ux.confirm(
        "Would you like to open the Configuration Wizard in your browser? (yes/no)",
      );

      if (shouldOpen) {
        await open(configUrl);
      } else {
        console.log(
          `\nYou can configure the test instance later by visiting the following URL:\n${configUrl}`,
        );
      }
    }

    return false;
  }

  return true;
}

export type BuildFlagStringOptions = {
  payloadFilePath?: string;
  contentType?: string;
  tailLogs?: boolean;
  tailStepResults?: boolean;
  sync?: boolean;
  autoEndPoll?: boolean;
  resultFilePath?: string;
};

export const buildFlagString = (options: BuildFlagStringOptions): string => {
  const {
    payloadFilePath,
    contentType,
    tailLogs,
    tailStepResults,
    sync,
    autoEndPoll,
    resultFilePath,
  } = options;

  const flags: string[] = [];

  if (payloadFilePath) {
    flags.push(`-p=${payloadFilePath}`);
    flags.push(`-c=${contentType}`);
  }
  if (tailLogs) flags.push("--tail-logs");
  if (tailStepResults) flags.push("--tail-results");
  if (sync) flags.push("--sync");
  if (autoEndPoll) flags.push("--cni-auto-end");
  if (resultFilePath) flags.push(`-r=${resultFilePath}`);

  return flags.join(" ");
};
