import * as path from "path";
import { ProjectStructure, InputPropertyStructure } from "./index.js";
import {
  VariableDeclarationKind,
  ObjectLiteralExpression,
  Writers,
  SourceFile,
  MethodSignature,
  ParameterDeclaration,
} from "ts-morph";
import { getParamTypeDefinition, getActionMethods } from "./parse.js";
import { getActionMethodInputProperties, writeInputs } from "./input.js";
import { createDescription, pascalCase } from "./util.js";
import { uniq, uniqBy, sortBy, camelCase } from "lodash-es";

export interface ActionInput {
  shouldImport: boolean;
  name: string;
  properties: InputPropertyStructure[];
  paramTypeDefinition: SourceFile;
}
export interface ActionObject {
  inputs: ActionInput[];
  method: string;
}

interface Action {
  service: string;
  key: string;
  display: { label: string; description: string };
  methodSignature: MethodSignature;
  actionObject: ActionObject;
}

const getPerformFunctionWSDL = (projectTemplatePath: string, action: Action) => {
  return `const client = await createClientAsync(path.join(__dirname, "${path.basename(
    projectTemplatePath,
  )}"), headers);
        const [result] = await client.${action.methodSignature.getName()}(${action.actionObject.inputs
          .map((input) => {
            return `{${
              input.shouldImport
                ? input.properties.map(({ propertyName }) => propertyName).join(", ")
                : ""
            }}`;
          })
          .join(",")});`;
};

const instantiatePerformFunction = (action: Action, project: ProjectStructure) => {
  const { projectTemplatePath } = project;

  const performFunction = getPerformFunctionWSDL(projectTemplatePath, action);

  const performParams = action.actionObject.inputs
    .filter(({ shouldImport }) => shouldImport)
    .map(({ properties, shouldImport }) => {
      const name = properties.map(({ propertyName }) => propertyName).join(",");
      return shouldImport ? name : "";
    });
  const updatedPerformParams = [...performParams, "headers"];

  return `async ({logger}, ${
    updatedPerformParams.length > 0
      ? `{ ${updatedPerformParams.join(", ")} }: Record<string,any>`
      : ""
  }) => {
    ${performFunction}
    return {data: result};
      }`;
};

// Gather the definition of the type
// used as a parameter for our perform function
const generateActionObject = (
  methodSignature: MethodSignature,
  project: ProjectStructure,
): ActionObject => {
  const inputPropertiesMapping = methodSignature
    .getParameters()
    .map((parameter: ParameterDeclaration) => {
      const input = {
        name: parameter.getName(),
        properties: getActionMethodInputProperties(
          parameter,
          getParamTypeDefinition(project, parameter),
        ),
        paramTypeDefinition: getParamTypeDefinition(project, parameter),
      } as ActionInput;

      input.shouldImport =
        (input.properties.length > 0 && input.paramTypeDefinition !== undefined) ||
        input.paramTypeDefinition === undefined;

      return input;
    });

  return {
    inputs: inputPropertiesMapping,
    method: "",
  };
};

// Compile all the information needed to build
// an action function
const compileAction = (
  actionService: string,
  actionMethod: MethodSignature,
  project: ProjectStructure,
): Action => ({
  service: actionService,
  key: camelCase(actionMethod.getName()),
  display: {
    label: pascalCase(actionMethod.getName())
      .split(/(?=[A-Z])/)
      .join(" "),
    description:
      actionMethod.getJsDocs()?.length > 0
        ? `${actionMethod.getJsDocs()[0].getDescription()}`
        : "Generated by Prismatic.",
  },
  methodSignature: actionMethod,
  actionObject: generateActionObject(actionMethod, project),
});

const writeAction = async (action: Action, project: ProjectStructure): Promise<void> => {
  const { actionFile } = project;

  // Apparently you can't generate an Object without adding it to the file
  // so this is our place holder to use as a template
  const placeholder = actionFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    declarations: [{ name: "genericActionPayload", initializer: Writers.object({}) }],
  });
  const object = placeholder.getDeclarations()[0].getInitializer() as ObjectLiteralExpression;

  const inputFields = action.actionObject.inputs.flatMap(({ properties, shouldImport, name }) => {
    if (properties.length > 0) {
      return properties.map(({ propertyName }) => propertyName);
    }
    return shouldImport ? [name] : [];
  });

  object.addPropertyAssignments([
    {
      name: "display",
      initializer: `{
      label: "${action.display.label}",
      description: \`${createDescription(action.display.description)}\`
      }`,
    },
    {
      name: "perform",
      initializer: instantiatePerformFunction(action, project),
    },
    {
      name: "inputs",
      initializer: `{${[
        ...inputFields,
        `headers: {
            label: "Headers",
            type: "code",
            language: "json",
            comments: "Provide headers to the SOAP client",
            default: '{}'
          }`,
      ]}}`,
    },
  ]);

  //Add the action payload to the action
  actionFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    declarations: [
      {
        name: action.key,
        initializer: `action(${object.print()})`,
      },
    ],
    isExported: true,
  });

  // Remove the temporary action object now that we've placed our payload
  // into the action
  placeholder.remove();
};

const writeServicesImport = async (
  services: string[],
  { actionFile, definitionDirectory }: ProjectStructure,
): Promise<void> => {
  actionFile.addImportDeclaration({
    moduleSpecifier: `../${definitionDirectory}/index`,
    namedImports: services,
  });
};

const writeInputsImport = async (
  inputNames: string[],
  { actionFile }: ProjectStructure,
): Promise<void> => {
  actionFile.addImportDeclaration({
    moduleSpecifier: "./inputs",
    namedImports: inputNames,
  });
};

export const generateActions = async (project: ProjectStructure): Promise<void> => {
  const { actionFile, inputsFile } = project;

  const methods = getActionMethods(project);
  const actions = sortBy(
    Object.entries(methods).flatMap(([service, actionMethods]) => {
      const dedupedActions = uniqBy(actionMethods, (a) => a.getName());
      return dedupedActions.map((action) => compileAction(service, action, project));
    }),
    ({ key }) => key,
  );

  const inputs = actions
    .flatMap(({ actionObject }) => actionObject.inputs)
    .filter(({ shouldImport }) => shouldImport)
    .flatMap(({ properties }) => properties);
  const dedupedInputs = sortBy(
    uniqBy(inputs, (i) => i.propertyName.toLowerCase()),
    (i) => i.propertyName,
  );

  await writeInputs(project, dedupedInputs);
  inputsFile.organizeImports();
  inputsFile.formatText();
  await inputsFile.save();

  const services = actions.map(({ service }) => service);
  const dedupedServices = sortBy(uniq(services));
  await writeServicesImport(dedupedServices, project);

  const inputNames = dedupedInputs.map(({ propertyName }) => propertyName);

  await writeInputsImport(inputNames, project);

  const actionPromises = actions.map((action) => writeAction(action, project));
  await Promise.all(actionPromises);

  const actionExports = sortBy(actions.map(({ key }) => key));
  actionFile.addExportAssignment({
    isExportEquals: false,
    expression: `{${actionExports.join(",\n")}}`,
  });

  actionFile.organizeImports();
  actionFile.formatText();
  await actionFile.save();
};
